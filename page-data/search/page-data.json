{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n'cv2.cv2' has no attribute 'SIFT_create'\n\nOpenCV의 [Feature Matching 튜토리얼](https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_feature2d/py_matcher/py_matcher.html) 중 FLANN 기반 매칭을 위해 SIFT 함수를 사용하는 예제가 있다.\n그런데, OpenCV 모듈을 설치하고 예제와 동일하게 모듈을 불러와 SIFT_create 함수를 실행하는데 아래와 같은 에러가 발생했다.\n\n```\nAttributeError: module 'cv2.cv2' has no attribute 'SIFT_create'\n```\n\ncv2 모듈에 SIFT_create 함수가 없다는 뜻인데, 이것때문에 모듈을 재설치도 해보고 낮은 버전의 OpenCV 를 사용할까 생각도 했지만, 방법을 찾아 공유하려고 한다.\n\n사용하려는 기능이 메인 모듈에 있는게 아닌, 추가 모듈 `xfeatures2d`에 존재했었다. 기존 OpenCV 모듈을 삭제 후,  추가 모듈까지 설치한다. ( [OpenCV 설명서](https://docs.opencv.org/master/) 에서 메인 & 추가 모듈 목록 확인 )\n\n```\npip3 uninstall opencv-python\npip3 install opencv-contrib-python\n```\n\n이제 추가 모듈 `xfeatures2d`의 SIFT_create() 함수를 호출할 수 있다.\n\n```python\nimport cv2 as cv\n\n# Initiate SIFT detector\nsift = cv.xfeatures2d.SIFT_create()\n```\n\n","excerpt":"'cv2.cv2' has no attribute 'SIFT_create' OpenCV의 Feature Matching 튜토리얼 중 FLANN 기반 매칭을 위해 SIFT 함수를 사용하는 예제가 있다.\n그런데, OpenCV…","fields":{"slug":"/opencv-has-no-attribute-sift-create/"},"frontmatter":{"date":"Jul 27, 2020","title":"cv2.cv2 has no attribute SIFT_create","tags":["python","error","opencv"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"**본 포스팅은 정답이 아닙니다. 저 스스로 푼 답이며, 문제를 푸는 사람마다 접근 방식이나 풀이가 다를 수 있습니다.**\n\n* **문제:** \n\n  > 예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.\n\n* **입력:**\n\n  > 첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.\n\n* **출력:**\n\n  > 첫째 줄부터 차례대로 별을 출력한다.\n\n- **예제 입력:** \n\n  > ```\n  > 1\n  > ```\n  >\n  > ```\n  > 2\n  > ```\n  >\n  > ```\n  > 3\n  > ```\n  >\n  > ```\n  > 4\n  > ```\n  \n- **예제 출력:** \n\n  > ```\n  > *\n  > ```\n  >\n  > ```\n  > *\n  >  *\n  > *\n  >  *\n  > ```\n  >\n  > ```\n  > * *\n  >  *\n  > * *\n  >  *\n  > * *\n  >  *\n  > ```\n  >\n  > ```\n  > * *\n  >  * *\n  > * *\n  >  * *\n  > * *\n  >  * *\n  > * *\n  >  * *\n  > ```\n\n\n## 풀이\n1을 입력했을 때는 * 기호를 하나만 출력한다. 그 외에는 해당 별의 좌표를 (x, y)로 보고, x + y 가 짝수일 때 * 기호를 출력하고 홀수일 때는 공백을 출력한다.\n\n```python\nn = int(input())\n\nif n == 1:\n    print('*')\nelse:\n    for i in range(1, (n * 2 + 1)):\n        c = ''\n        for j in range(1, n + 1):\n            if (i + j) % 2 == 0:\n                c += '*'\n            else:\n                c += ' '\n        print(c)\n```\n\n","excerpt":"본 포스팅은 정답이 아닙니다. 저 스스로 푼 답이며, 문제를 푸는 사람마다 접근 방식이나 풀이가 다를 수 있습니다. 문제:  예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요. 입력: 첫째 줄에 N(1 ≤ N ≤ 10…","fields":{"slug":"/algorithm-baekjoon-10996/"},"frontmatter":{"date":"Jul 26, 2020","title":"백준 알고리즘 10996번 문제 - Python","tags":["algorithm","python"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"* **문제:** \n\n  > 상근날드에서 가장 잘 팔리는 메뉴는 세트 메뉴이다. 주문할 때, 자신이 원하는 햄버거와 음료를 하나씩 골라, 세트로 구매하면, 가격의 합계에서 50원을 뺀 가격이 세트 메뉴의 가격이 된다.  \n  > 햄버거는 총 3종류 상덕버거, 중덕버거, 하덕버거가 있고, 음료는 콜라와 사이다 두 종류가 있다.  \n  > 햄버거와 음료의 가격이 주어졌을 때, 가장 싼 세트 메뉴의 가격을 출력하는 프로그램을 작성하시오.\n\n- **입력:** \n\n  > 입력은 총 다섯 줄이다. 첫째 줄에는 상덕버거, 둘째 줄에는 중덕버거, 셋째 줄에는 하덕버거의 가격이 주어진다. 넷째 줄에는 콜라의 가격, 다섯째 줄에는 사이다의 가격이 주어진다. 모든 가격은 100원 이상, 2000원 이하이다.\n  \n- **출력:** \n\n  > 첫째 줄에 가장 싼 세트 메뉴의 가격을 출력한다.\n\n\n## 풀이\n입력의 조건을 보자. 첫 번째부터 세 번째 까지의 입력은 버거, 네 번째, 다섯 번째의 입력은 음료이다. 우선 버거의 가격을 입력받을 배열과 음료의 가격을 입력받을 배열을 선언한다.  \n버거와 음료 배열에 값을 추가한뒤, min함수를 이용하여 각 배열의 최소값을 더한 후 50을 빼준다.\n\n```python\ndrinks, buggers = [], []\n\nfor i in range(3):\n    bugger = int(input())\n    buggers.append(bugger)\n\nfor i in range(2):\n    drink = int(input())\n    drinks.append(drink)\n\nprint((min(buggers) + min(drinks)) - 50)\n```\n\n","excerpt":"문제:  상근날드에서 가장 잘 팔리는 메뉴는 세트 메뉴이다. 주문할 때, 자신이 원하는 햄버거와 음료를 하나씩 골라, 세트로 구매하면, 가격의 합계에서 50원을 뺀 가격이 세트 메뉴의 가격이 된다. 햄버거는 총…","fields":{"slug":"/algorithm-baekjoon-5543/"},"frontmatter":{"date":"Jul 12, 2020","title":"백준 알고리즘 5543번 문제 - Python","tags":["algorithm","python"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"* **문제:** \n  \n  > 0보다 크거나 같고, 99보다 작거나 같은 정수가 주어질 때 다음과 같은 연산을 할 수 있다. 먼저 주어진 수가 10보다 작다면 앞에 0을 붙여 두 자리 수로 만들고, 각 자리의 숫자를 더한다. 그 다음, 주어진 수의 가장 오른쪽 자리 수와 앞에서 구한 합의 가장 오른쪽 자리 수를 이어 붙이면 새로운 수를 만들 수 있다. 다음 예를 보자.  \n  > 26부터 시작한다. 2+6 = 8이다. 새로운 수는 68이다. 6+8 = 14이다. 새로운 수는 84이다. 8+4 = 12이다. 새로운 수는 42이다. 4+2 = 6이다. 새로운 수는 26이다.  \n  > 위의 예는 4번만에 원래 수로 돌아올 수 있다. 따라서 26의 사이클의 길이는 4이다.  \n  > N이 주어졌을 때, N의 사이클의 길이를 구하는 프로그램을 작성하시오.\n  \n- **입력:** \n  \n  > 첫째 줄에 N이 주어진다. N은 0보다 크거나 같고, 99보다 작거나 같은 정수이다.\n  \n- **출력:** \n  \n  > 첫째 줄에 N의 사이클 길이를 출력한다.\n\n## 풀이\n\n입력 받은 정수와 계산에 쓰일 변수, 그리고 카운트에 쓰일 변수 n, m, count을 정의하고 문제에서 요구하는 식을 구현한다.  \n입력 받은 정수의 십의 자리와 일의 자리를 구한다. // 연산자는 정수형의 몫을 반환하기 때문에 입력 받은 정수가 한자리일 때 십의자리는 0이된다. 일의 자리와 십의 자리를 더하여 합을 구한 후 % 연산자를 사용하여 합의 일의자리를 구하고, 입력 받았던 정수의 일의자리에 10을 곱하여 십의 자리로 만들어 두 수를 더하여 조건을 비교한다. 두 수가 같다면 반복문을 종료하고 그렇지 않다면 계산에 쓰일 변수에 대입한다.\n\n```python\nm = n = int(input()) # 계산에 쓰일 변수와, 최초 입력받은 변수\ncount = 0 # 카운트에 쓰일 변수\nwhile True:\n    tens = m // 10 # 십의 자리\n    units = m % 10 # 일의 자리\n    _sum = tens + units # 합계\n    result = (units * 10) + (_sum % 10) # 문제에서 제시한 조건식\n    count += 1 # 카운트 1 증가\n    if result == n: # 조건 비교\n        print(count) \n        break # 조건이 참이라면 반복문 종료\n    m = result # 거짓이라면 계산에 쓰일 변수에 조건식의 결과를 대입\n```\n\n","excerpt":"문제:  0보다 크거나 같고, 99보다 작거나 같은 정수가 주어질 때 다음과 같은 연산을 할 수 있다. 먼저 주어진 수가 10보다 작다면 앞에…","fields":{"slug":"/algorithm-baekjoon-1110/"},"frontmatter":{"date":"Jul 08, 2020","title":"백준 알고리즘 1110번 문제 - Python","tags":["algorithm","python"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"* **문제:** \n\n  > 상근이는 매일 아침 알람을 듣고 일어난다. 알람을 듣고 바로 일어나면 다행이겠지만, 항상 조금만 더 자려는 마음 때문에 매일 학교를 지각하고 있다.  \n  > 상근이는 모든 방법을 동원해보았지만, 조금만 더 자려는 마음은 그 어떤 것도 없앨 수가 없었다.  \n  > 이런 상근이를 불쌍하게 보던, 창영이는 자신이 사용하는 방법을 추천해 주었다.  \n  > 바로 \"45분 일찍 알람 설정하기\"이다.  \n  > 이 방법은 단순하다. 원래 설정되어 있는 알람을 45분 앞서는 시간으로 바꾸는 것이다. 어차피 알람 소리를 들으면, 알람을 끄고 조금 더 잘 것이기 때문이다. 이 방법을 사용하면, 매일 아침 더 잤다는 기분을 느낄 수 있고, 학교도 지각하지 않게 된다.  \n  > 현재 상근이가. 설정한 알람 시각이 주어졌을 때, 창영이의 방법을 사용한다면, 이를 언제로 고쳐야. 하는지 구하는 프로그램을 작성하시오.\n\n- **입력:** \n\n  > 첫째 줄에 두 정수 H와 M이 주어진다. (0 ≤ H ≤ 23, 0 ≤ M ≤ 59) 그리고 이것은 현재 상근이가 설정한 놓은 알람 시간 H시 M분을 의미한다.  \n  > 입력 시간은 24시간 표현을 사용한다. 24시간 표현에서 하루의 시작은 0:0(자정)이고, 끝은 23:59(다음날 자정 1분 전)이다. 시간을 나타낼 때, 불필요한 0은 사용하지 않는다.\n\n- **출력:** \n\n  > 첫째 줄에 상근이가 창영이의 방법을 사용할 때, 설정해야 하는 알람 시간을 출력한다. (입력과 같은 형태로 출력하면 된다.)\n\n\n## 풀이\nh, m 두 정수를 입력받고 m-45의 결과 값이 음수 일 때 60을 더해주어 양수로 만들고,\nh-1의 결과 값이 음수라면 24를 더하여 24시간 단위로 바꾸어준다.\n```python\nh, m = map(int, input().split())\n\nm = m - 45\nif m < 0:\n    m = 60 + m\n    h = h - 1\n    if h < 0:\n        h = 24 + h\nprint(h, m)\n```\n\n","excerpt":"…","fields":{"slug":"/algorithm-baekjoon-2884/"},"frontmatter":{"date":"Jul 04, 2020","title":"백준 알고리즘 2884번 문제 - Python","tags":["algorithm","python"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"* **문제:** \n  \n  > 두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하십시오.\n  \n- **입력:** \n  \n  > 첫째 줄에 A와 B가 주어진다. ( 0 < A, B < 10 )\n  \n- **출력:** \n  \n  > 첫째 줄에 A + B를 출력한다.\n\n해당 문제를 풀기 위해서는 input(), split(), map() 함수에 대해 알 필요가 있다.\n\n우선, A와 B를 입력 받기 위해 input 함수와 split 함수를 사용해야한다. input 함수는 사용자가 입력한 값을 어떤 변수에 대입하고 싶을 때 사용한다. **input 함수로 반환되는 타입은 모두 문자열이다.**\n\n```python\n>>> a = input()\n안녕?\n>>> a\n'안녕?'\n# 위 예문 처럼 input은 입력받는 모든 것을 문자열로 취급한다.\n```\n\nsplit 함수는 **문자열 자료형**에서 입력 받은 인자를 구분자로 하여 문자열을 나누어준다. 인자가 없다면 공백 (스페이스, 탭, 엔터 등)을 기준으로 문자열을 나눈다. 이렇게 나누어진 문자열은 list에 하나씩 들어가게 된다.\n\n```python\n>>> a, b = input().split()\n1 2\n>>> print('a = {}, b = {}'.format(a, b))\na = 1, b =2\n```\n\n하지만 위와 같은 풀이로는 문제를 해결할 수 없다. 그 이유는 input 함수가 문자열을 반환하기 때문이다.\n\n```python\n>>> type(a)\n<class 'str'>\n# 실제로 type 함수를 사용하여 확인해보면 문자열임을 알 수 있다.\n```\n\n그렇기 때문에 map함수나 형변환을 이용하여 문제를 해결해야한다. map(f, iterable) 함수는 함수(f)와 반복 가능한(iterable) 자료형을 입력으로 받는다. **map 함수는 입력받은 자료형의 각 요소를 함수(f)가 수행한 결과로 묶어서 반환해주는 함수이다.** map 함수에 대한 내용은 다른 글에서 조금 더 자세하게 다루겠습니다.\n\n## 풀이\n\n```python\n# map\n>>> a, b = map(int, input().split())\n1 2\n>>> print(a + b)\n3\n\n# 형변환\n>>> a, b = input().split()\n1 2\n>>> print(int(a) + int(b))\n```\n\n","excerpt":"문제:  두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하십시오. 입력:  첫째 줄에 A와 B가 주어진다. ( 0 < A, B < 10 ) 출력:  첫째 줄에 A + B를 출력한다. 해당 문제를 풀기 위해서는 input…","fields":{"slug":"/algorithm-baekjoon-1000/"},"frontmatter":{"date":"Jun 30, 2020","title":"백준 알고리즘 1000번 문제 - Python","tags":["algorithm","python"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}}}